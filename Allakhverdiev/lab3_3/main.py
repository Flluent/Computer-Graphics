import numpy as np
import matplotlib.pyplot as plt

# ===============================================
# 1. КОНСТАНТЫ И ВХОДНЫЕ ДАННЫЕ
# ===============================================

# Вершины треугольника: (x, y)
V1 = np.array([100, 100], dtype=np.float32)
V2 = np.array([400, 200], dtype=np.float32)
V3 = np.array([250, 450], dtype=np.float32)

# Цвета вершин в формате RGB (0-255)
C1 = np.array([255, 0, 0], dtype=np.float32)  # Красный
C2 = np.array([0, 255, 0], dtype=np.float32)  # Зеленый
C3 = np.array([0, 0, 255], dtype=np.float32)  # Синий

# Размер холста
WIDTH = 512
HEIGHT = 512

# Инициализация холста (черный фон)
canvas = np.zeros((HEIGHT, WIDTH, 3), dtype=np.uint8)


# ===============================================
# 2. ВСПОМОГАТЕЛЬНАЯ ФУНКЦИЯ ДЛЯ БАРИЦЕНТРИЧЕСКИХ КООРДИНАТ
# ===============================================

def edge_function(V_a, V_b, P):
    """
    Вычисляет 'ориентированную площадь' для определения, находится ли
    точка P слева или справа от ребра (V_a, V_b).
    (P_x - V_a_x) * (V_b_y - V_a_y) - (P_y - V_a_y) * (V_b_x - V_a_x)
    """
    return (P[0] - V_a[0]) * (V_b[1] - V_a[1]) - (P[1] - V_a[1]) * (V_b[0] - V_a[0])


# ===============================================
# 3. АЛГОРИТМ РАСТЕРИЗАЦИИ ТРЕУГОЛЬНИКА
# ===============================================

def draw_triangle_gradient(V1, V2, V3, C1, C2, C3, canvas):
    # 3.1. Ограничивающий прямоугольник (Bounding Box)

    # Находим минимальные и максимальные координаты (ограниченные размерами холста)
    min_x = max(0, int(np.floor(min(V1[0], V2[0], V3[0]))))
    max_x = min(WIDTH - 1, int(np.ceil(max(V1[0], V2[0], V3[0]))))
    min_y = max(0, int(np.floor(min(V1[1], V2[1], V3[1]))))
    max_y = min(HEIGHT - 1, int(np.ceil(max(V1[1], V2[1], V3[1]))))

    # 3.2. Вычисление общей площади (Denominator)

    # Общая ориентированная площадь треугольника (нужна для нормализации)
    area_denominator = edge_function(V1, V2, V3)

    # Проверка на вырожденный треугольник
    if area_denominator == 0:
        print("Ошибка: Вырожденный треугольник (площадь равна нулю).")
        return

    # 3.3. Итерация по пикселям Bounding Box и окрашивание

    for x in range(min_x, max_x + 1):
        for y in range(min_y, max_y + 1):

            P = np.array([x + 0.5, y + 0.5])  # Центр пикселя

            # Вычисляем ненормированные барицентрические координаты (w0, w1, w2)
            # w0 - вес V1 (площадь подтреугольника P-V2-V3)
            # w1 - вес V2 (площадь подтреугольника P-V3-V1)
            # w2 - вес V3 (площадь подтреугольника P-V1-V2)
            w0 = edge_function(V2, V3, P)
            w1 = edge_function(V3, V1, P)
            w2 = edge_function(V1, V2, P)

            # Проверка нахождения точки внутри треугольника
            # (Все веса должны быть положительными или равными нулю)
            if (w0 >= 0 and w1 >= 0 and w2 >= 0) or (w0 <= 0 and w1 <= 0 and w2 <= 0):
                # Нормализация барицентрических координат (alpha, beta, gamma)
                alpha = w0 / area_denominator  # Вес V1
                beta = w1 / area_denominator  # Вес V2
                gamma = w2 / area_denominator  # Вес V3

                # Интерполяция цвета по барицентрическим координатам
                # C_p = alpha * C1 + beta * C2 + gamma * C3

                # Векторное умножение для всех каналов сразу
                color_vector = alpha * C1 + beta * C2 + gamma * C3

                # Приведение к целому типу (uint8) и ограничение [0, 255]
                R, G, B = np.clip(color_vector, 0, 255).astype(np.uint8)

                # Окрашивание пикселя на холсте
                canvas[y, x] = [R, G, B]


# Вызов функции отрисовки
draw_triangle_gradient(V1, V2, V3, C1, C2, C3, canvas)

# ===============================================
# 4. ОТОБРАЖЕНИЕ РЕЗУЛЬТАТА
# ===============================================

plt.figure(figsize=(6, 6))
plt.imshow(canvas)
plt.title('Градиентное окрашивание треугольника (Барицентрические координаты)')
plt.xlabel('X')
plt.ylabel('Y')
plt.grid(True, alpha=0.3)
plt.show()